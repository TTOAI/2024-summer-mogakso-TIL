
#### 역사
- EJB - Enterprise Java Beans
	- 옛날, 자바 진영 표준 기술
	- 비싸고 쓰기 어려웠음
- 스프링
	- EJB 컨테이너 대체
	- 단순함
	- 현재 사실상 표준 기술
- 하이버네이트
	- EJB 엔티티빈 기술 대체
	- JPA의 구현체들 중 하나
		-  점유율 80% 이상
- JPA
	- 자바 표준 인터페이스
	- 하이버네이트를 통해 만듦
		- 하이버네이트의 실용성 + 표준의 안정성, 정제성

#### 스프링
- 필수
	- 스프링 프레임워크
	- 스프링 부트
- 선택
	- 스프링 데이터
	- 스프링 세션
	- 스프링 시큐리티
	- 스프링 Rest Docs
	- 스프링 배치
	- 스프링 클라우드

#### 스프링 프레임워크
- 핵심 기술 (스프링 DI 컨테이너, AOP, 이벤트, ...)
- 웹 기술 (스프링 MVC, 스프링 WebFlux)
- 데이터 접근 기술 (트랜잭션, JDBC, ORM 지원, XML 지원)
- 기술 통합 (캐시, 이메일, 원격 접근, 스케줄링)
- 테스트 (스프링 기반 테스트 지원)
- 언어 (코틀린, 그루비)

#### 스프링 부트
- 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
- 스프링 3rd parth(외부) 라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정
- 스프링 부트를 쓰면 스프링 프레임워크까지 자동으로 땡겨서 씀

#### '스프링'?
- 스프링 DI 컨테이너 기술
- 스프링 컨테이너
- 스프링 부트, 스프링 프레임워크 등을 포함한 스프링 생태계

#### 스프링의 핵심
- 자바 언어 기반의 프레임워크
- 자바의 객체 지향적인 특징을 잘 살려내는 프레임워크

#### 객체 지향 프로그래밍
- 객체들의 모임
- 각각의 객체는 메세지를 주고 받고 데이터를 처리하며 협력함
- 프로그램을 유연하고 변경이 용이하게 만듦
	- 대규모 소프트웨어 개발에 용이
	- 다형성이라는 특징 때문

#### 다형성
- 역할과 구현을 분리
	- 역할: 인터페이스
	- 구현: 인터페이스를 구현한 클래스, 구현 객체
	- (구현 대상을 이용할) 클라이언트가 알아야 할 것
		- 대상의 역할(인터페이스)
	- 클라이언트가 몰라도 될 것: 구현 대상의 내부 구조
		- 구현 대상의 내부 구조나 그 자체(객체)가 변경되어도 영향 X
	- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 가능
	- 인터페이스가 변하면 클라이언트, 서버 모두에 큰 변경 발생
		- 인터페이스를 안정적으로 설계하는 것이 중요함

#### 객체
- 클라이언트(요청), 서버(응답)
- 서로 협력 관계를 가짐

#### SOLID: 좋은 객체 지향 설계의 5가지 원칙
- [SRP](#SRP): 단일 책임 원칙(Single Responsibility Principle)
- [OCP](#OCP): 개방-폐쇄 원칙(Open/Closed Principle)
- [LSP](#LSP): 리스코프 치환 원칙(Liskov Substitution Principle)
- [ISP](#ISP): 인터페이스 분리 원칙(Interface Segregation Principle)
- [DIP](#DIP): 의존관계 역전 원칙(Dependency Inversion Principle)

#### SRP
- 하나의 클래스는 하나의 책임만 가져야 한다
- 중요한 기준은 변경
- 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것

#### OCP
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다
- 인터페이스를 구현한 새로운 클래스를 통해 새로운 기능을 구현
- 문제점
	- 구현 객체를 변경하려면 클라이언트 코드를 변경해야 함
	- 분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없음
	- -> DIP를 위반했기 때문
	- -> 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요함
	- -> IoC, DI

#### LSP
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다
- 하위 클래스는 인터페이스의 규약을 다 지켜야 함
-  ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반

#### ISP
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
- 인터페이스가 명확해지고, 대체 가능성이 높아짐

#### DIP
- 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안 된다
- 의존성 주입(Dependency Injection)은 이 원칙을 따르는 방법 중 하나
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻

#### 다시 스프링으로 돌아와서
- 스프링은 다음 기술로 다형성과 OCP, DIP를 가능하게 지원
	- DI(Dependency Injection): 의존관계, 의존성 주입
	- DI 컨테이너 제공

